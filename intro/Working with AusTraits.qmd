---
title: "AusTraits"
format: html
editor_options: 
  chunk_output_type: console
---

# Introduction & Goals

The two goals of this prpactical are to:

1. Get hands on experience with AusTraits, as an example of a big-data resource on traits of biolgocial organisms
2. Refresh, extend, and practice your skills in data manipulation and visualisation 
3. Learn some fancy tricks when working with tables of data: joining relational tables, pvotting tables, and nesting tables

As background, we suggest reading the paper describing AusTraits:

- Falster et al 2021 <https://doi.org/10.1038/s41597-021-01006-6>
- The AusTraits data dictionary, available as a download at https://zenodo.org/record/7583087 (see the file [dictionary.html](https://zenodo.org/record/7583087/files/dictionary.html?download=1))

# Setup 

We will be using R and Rstudio for this practical, with the packages `tidyverse` and `austraits` installed. To install the packages (if you don't already have them installed), run the following code in the console:

```{r}
# Uncomment the next lines as needed
# install.packages("tidyverse")
# devtools::install_github("traitecoevo/austraits")
```

After installing, load the packages

```{r}
library(tidyverse)
library(austraits)
```

## Accessing AusTraits

You can access the data from AusTraits in either of two ways:

1. Use the package [austraits](https://github.com/traitecoevo/austraits) to download the data directly from the web. This is the easiest way to get started.

```{r}
austraits <- load_austraits(version = "4.1.0", path = "intro/downloads")
```

2. Manually download the data to your computer from <https://zenodo.org/record/7583087/files/austraits-4.1.0.rds?download=1> and save it in the folder `downloads` in this project, then read it in using

```{r}
austraits <- readRDS("intro/downloads/austraits-4.1.0.rds")
```

We've designed AusTraits as a fully open resources, meaning anyone can directly access the data. However, we do ask that you cite the paper describing AusTraits in any publications that use the data.

# Exploring the data

In any analysis, you first need to investigate the structure of the dataset.

Working with a partner or small group, answer the following questions:

(hint - the dictionary will also be useful here)

1. What is the class of the object `austraits`?
```{r}

```

2. What are the names of the elements in `austraits`?
```{r}

```

3. What's in all the different elements of `austraits`?
```{r}

```


## Lists and  Tables (tibbles)

A list is simply that, an ordered list of any combination of items, such as integers, character strings, vectors, tables,or even a list of lists! 

```{r}
typeof(austraits)
names(austraits)
length(austraits)
```

You can access elements within the list

```{r}
austraits[["traits"]]

austraits[["traits"]][["trait_name"]]

# alternatively:
austraits$traits
austraits$traits$trait_name
```

Most elements of the AusTraits objects are tables (a.k.a. tibbles in R).

Challenge:

How many rows in each of these tables: taxa, contributors & locations

```{r}
nrow(austraits$locations)
nrow(austraits$contributors)
nrow(austraits$taxa)
```


## Working with tables

Chance to practice working with and summarising data

Common dplyr functions include:

- filter
- select
- mutate
- summarise
- group_by
- grepl


Challenges


1. How many taxa and traits are included?

```{r}
length(unique(austraits$traits$trait_name))
length(austraits$taxa$taxon_name)
```

Answer: taxa: 34017, traits: 464

Note: nrow() doesn't work here! Why not? (hint: use the typeof() function)


2. From the taxa table, how many accepted taxa are there?

```{r}
taxa_status <- austraits$taxa %>% select(taxonomic_status, taxon_name)

taxa_status %>% filter(taxonomic_status == "accepted") %>% nrow()
```

Answer: 33197


3. How many trait records in the top 5 recorded taxa?

```{r}
trait_records <- austraits$traits %>% 
  group_by(trait_name) %>%
  select(trait_name, value, observation_id) %>%
  na.omit()

map(trait_records$value, ~sum(unique(.x)))
```

Answer: 


4. What is the range of values in these 2 traits: seed_N_per_seed_dry_mass, leaf_dry_mass, flower_colour

```{r}
seeds <- austraits$traits %>% filter(trait_name == "seed_N_per_seed_dry_mass") %>% select(trait_name, value, taxon_name, unit)
range(as.numeric(seeds$value))

leaves <- austraits$traits %>% filter(trait_name == "leaf_dry_mass") %>% select(trait_name, value, taxon_name, unit) %>% na.omit()
range(as.numeric(leaves$value))
```

Answer: seeds = 28.80 - 125.51 mg/g, leaves = 0.1 - 10538.0 mg


5. What proportion of flower bearing taxon contain green flowers? 

```{r}
flowers <- austraits$traits %>% 
  filter(trait_name == "flower_colour") %>% 
  select(trait_name, value, taxon_name)

nrow(flowers)
flowers %>% filter(grepl('green', value)) %>% nrow()
```

Answer: 16.4%


6. What traits were excluded from the dataset?

```{r}
unique(austraits$excluded_data$trait_name)
```

Answer: There should be 187


7. Let's have a look at the wood_density trait, made a new data frame object and isolate this trait and the taxon_name, trait_name, value and unit columns. How many taxa are there?

```{r}
wood_density <- austraits$traits %>% 
  filter(trait_name == "wood_density") %>% 
  select(taxon_name, trait_name, value, unit)

length(unique(wood_density$taxon_name))
```

Answer: 1984


8. Now make a column converting wood density into kg, and determine the max, min and mean values

```{r}
wood_density <- wood_density %>% 
  mutate(wood_density_kg = as.numeric(value)*1E03, count = row_number())

wood_density$wood_density_kg %>% max()
wood_density$wood_density_kg %>% min()
wood_density$wood_density_kg %>% mean()
```

Answer: min = 57.1kg, max = 1260kg, mean = 608.6kg


9. How many contributors are from Australian institutions?

```{r}
Aussies <- filter(grepl('Australia', austraits$contributors$affiliation))
```

Answer:


10. What kinds of records are there, are they from literature, lab, specimen, etc?

```{r}
unique(austraits$traits$basis_of_record)
```

Answer.



## Make plots with ggplot

Basic ggplot formulas

- we need to pass in the data, the x and y variables, the plot type, axes labels (with units!) and sometimes scales, title and any other aesthetics to make the plot easier to interpret and help to get the result across (e.g. colour scheme, faceting)

```{r}
your.data %>%
  ggplot(aes(xvar, yvar)) +
  geom_plot.type() +
  xlab() +
  ylab() +
  ggtitle() +
  theme_classic() +
  ...
```


Challenges

1. Plot the values for wood density from the object you created in Q7
```{r}
wood_density %>%
  ggplot(aes(as.numeric(value))) + 
  geom_histogram(binwidth = 0.03) + 
  xlab("Wood Density " ~ (kg/m^3)) +
  theme_classic(base_size = 17)
```

2. Recreate Figure 2a. from the Austraits paper (https://doi.org/10.1038/s41597-021-01006-6)

We want to plot the coverage of traits by taxa. This figure shows the coverage of taxa for each trait, yellow representing the presence of data, from a subset of 500 randomly selected taxa.

```{r}

```


# Some fancy tricks

If you've mastered the basics, here are some more advanced tricks to try out. 

## Joining tables

The traits table has a column `taxon_name` that links to the `taxon_name` column in the `taxa` table. This is an example of a relational database, where tables are linked by a common column. 

We can use the `left_join` function to join the two tables together. 

```{r}
austraits_joined <- left_join(austraits[["traits"]], austraits[["taxa"]], by = "taxon_name")
```

Challenge:

1. How many rows and columns are in the original and joined table?

```{r}

```

2. Why would you join the tables together?

```{r}

```

3. Can you see how to join other tables to the traits table?

```{r}

```

## Nesting tables

Nests embed tables within tables. Yes, that's right. 

The nest function comes from the `tidyr` package. It takes a table and a column name (.e.g. `dataset_id`), and creates a new column that contains a table, with one row for each value of the column `dataset_id`. 

```{r}
austraits_nested <- austraits$traits %>% nest(data = -dataset_id)

austraits_nested
```

You can access the nested table using the `data` column, e.g.
```{r}
austraits_nested$data[[1]]
austraits_nested$data[[2]]
```

You can then unnest using the `unnest` function, e.g.
```{r}
austraits_nested %>% unnest(cols = c(data))
```

Questions: 

1. How many rows and columns are in the original and nested table?

2. Why would you want to nest a dataframe?

## Pivot wider

Large databsses often come in `long format`, where each row is a single observation x trait combination. However, for some analyses, it is useful to have the data in `wide format`, where each row conatains all the traits for a single .

The `pivot_wider` function from the `tidyr` package allows you to reshape a dataset from long to wide format. Let's try it out. For this exercise let's use a subset of the data, e.g. the data with id `Falster_2005_1` (check out the paper here <https://doi.org/10.1111/j.0022-0477.2005.00992.x>) 

Challenge: Use the filter function to create a subset of the traits column with only the data from the paper `Falster_2005_1`. Also remove the records with trait_name of `huber_value` as it contains some dome duplicate records which make pivotting harder.

```{r}
data <- austraits$traits %>% 
  filter(dataset_id == "Falster_2005_1", trait_name != "huber_value")
```

Now let's pivot the data from long to wide format. 

```{r}
data %>% 
  select(taxon_name, trait_name, value) %>% 
  pivot_wider(names_from = trait_name, values_from = value)
```

Questions:

1. How many rows and columns are in the original and nested table?

2. Why would you want to nest a dataframe?



